<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>晋江科技馆集训Day 1</title>
      <link href="/2023/08undefined.html"/>
      <url>/2023/08undefined.html</url>
      
        <content type="html"><![CDATA[<p>PS: This is a note.</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><span id="more"></span><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="小鱼向左看"><a href="#小鱼向左看" class="headerlink" title="小鱼向左看"></a>小鱼向左看</h4><p><img src="/../img/%E6%99%8B%E6%B1%9F%E7%A7%91%E6%8A%80%E9%A6%86%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD/%E5%B0%8F%E9%B1%BC%E5%90%91%E5%B7%A6%E7%9C%8B.png" alt="题目"></p><p><code>输入样例</code></p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">64 3 0 5 1 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>输出样例</code></p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">0 0 0 3 1 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main() {int n,q[10001];cin&gt;&gt;n;for(int i=1;i&lt;=n;i++){cin&gt;&gt;q[i];}for(int i=1;i&lt;=n;i++){int sum=0;for(int j=i-1;j&gt;=1;j--){if(q[i]&gt;q[j]){sum++;}}cout&lt;&lt;sum&lt;&lt;" ";}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="更多例题可以上CSDN查看"><a href="#更多例题可以上CSDN查看" class="headerlink" title="更多例题可以上CSDN查看"></a>更多例题可以上<a href="https://blog.csdn.net/weixin_41960890/article/details/105319372">CSDN</a>查看</h4><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="可以看我之前的博客"><a href="#可以看我之前的博客" class="headerlink" title="可以看我之前的博客"></a>可以看我之前的<a href="http://bugs8.v6.army/2023/07/23/quan-zhou-shu-jia-ji-xun-day-1/">博客</a></h3>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 学习记录 </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泉州暑假集训Day 8</title>
      <link href="/2023/07undefined.html"/>
      <url>/2023/07undefined.html</url>
      
        <content type="html"><![CDATA[<p>PS: This is a note.</p><h2 id="图论基础"><a href="#图论基础" class="headerlink" title="图论基础"></a>图论基础</h2><span id="more"></span><h3 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h3><p>偷懒一波~ :)</p><p><a href="https://segmentfault.com/a/1190000013223267">segmentfault上某大佬的讲解</a></p><p><a href="https://zhuanlan.zhihu.com/p/135407927">知乎上某大佬的讲解</a></p><p>补充:</p><ul><li>节点的度: 无向图中与节点相连的边的数目,称为节点的度</li><li>节点的入度: 在有向图中,以这个节点为终点的有向边的数目</li><li>节点的出度: 在有向图中,以这个节点为起点的有向边的数目</li></ul><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><h4 id="邻接表编码"><a href="#邻接表编码" class="headerlink" title="邻接表编码"></a>邻接表编码</h4><ol><li>利用结构体+指针来实现(原始,不推荐)</li><li>利用STL库vector+结构体来实现</li></ol><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol><li>结构体</li><li>创建图<ol><li>顶点和边数，顶点需要用一维数组保存</li><li>获取顶点的下标，因为链接结点中的index域是顶点的下标值。</li><li>创建结点，通过头插法(或尾插法)把结点链接到头结点的尾部</li></ol></li><li>打印</li></ol><p>详细可见: <a href="https://www.cnblogs.com/cmusketeer/">TMusketeer的博客</a></p><h4 id="邻接表代码示例"><a href="#邻接表代码示例" class="headerlink" title="邻接表代码示例"></a>邻接表代码示例</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,j,k,w;struct node{    int to;    int w;};vector&lt;node&gt; v[100001];int main(){    node e;    scanf("%d%d",&amp;n,&amp;m);    for(int i=0;i&lt;m;i++){        scanf("%d%d%d",&amp;j,&amp;k,&amp;w);        e.to=k;        e.w=w;        v[j].push_back(e);        e.to=j;        v[k].push_back(e);    }    for(int i=1;i&lt;=n;i++)    {        for(vector&lt;node&gt;::iterator l=v[i].begin();k!=v[i].end();k++){            node t=*k;            printf("%d %d %d\n",i,t.to,t.w);        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 学习记录 </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泉州暑假集训Day 7</title>
      <link href="/2023/07undefined.html"/>
      <url>/2023/07undefined.html</url>
      
        <content type="html"><![CDATA[<p>PS: This is a note.</p><h2 id="基本字符串的应用及相关算法"><a href="#基本字符串的应用及相关算法" class="headerlink" title="基本字符串的应用及相关算法"></a>基本字符串的应用及相关算法</h2><span id="more"></span><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ol><li><a href="http://shihyu.github.io/books/apas01.html">ASCLL码表</a>: 美国标准<br><img src="/../img/%E6%B3%89%E5%B7%9E%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD/ASCLL.png" alt="ASCLL码表"></li><li>字符: 单引号、单字符: ‘0’,’A’,’a’(等价于单字节无符号整型数)</li><li>字符串<ol><li>实质: char数组</li><li>特殊结构: 以一个额外的0作为结尾</li><li>注意: ‘\0’是空字符,ASCLL编码是0,即空格字符不同</li></ol></li><li>子串: 字符串中连续的一段字符(依然是一个字符串)</li><li>前缀: 包含了第一个字符的子串</li><li>后缀: 包含了最后一个字符的子串</li><li>子序列: 字符串中的一些字符组成的新串(不一定要连续,但是要按照原来的顺序)</li><li>字典序: 首字符起,依次根据ASCLL码比较</li><li>回文串: 正写和倒写相同的字符串</li></ol><h3 id="字符数组-char"><a href="#字符数组-char" class="headerlink" title="字符数组(char *)"></a>字符数组(char *)</h3><h4 id="1、定义-char数组名-长度"><a href="#1、定义-char数组名-长度" class="headerlink" title="1、定义: char数组名[长度]"></a>1、定义: char数组名[长度]</h4><h4 id="2、存储"><a href="#2、存储" class="headerlink" title="2、存储"></a>2、存储</h4><p><img src="/../img/%E6%B3%89%E5%B7%9E%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD/%E5%AD%97%E7%AC%A6%E8%A1%A8.png" alt="字符串的储存"></p><h4 id="3、输入输出"><a href="#3、输入输出" class="headerlink" title="3、输入输出"></a>3、输入输出</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main(){   char c1,c2;   scanf("%c",&amp;c1);   c2=getchar();   printf("%c %d",c1,c2);   return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4、相关处理函数"><a href="#4、相关处理函数" class="headerlink" title="4、相关处理函数"></a>4、相关处理函数</h4><p>注:(1)、(2)记得看<strong>回放</strong></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="e-g-回文日期-洛谷P2010"><a href="#e-g-回文日期-洛谷P2010" class="headerlink" title="e.g. 回文日期(洛谷P2010)"></a>e.g. 回文日期(<a href="https://www.luogu.com.cn/problem/P2010">洛谷P2010</a>)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-乒乓球-洛谷P1042"><a href="#e-g-乒乓球-洛谷P1042" class="headerlink" title="e.g. 乒乓球(洛谷P1042)"></a>e.g. 乒乓球(<a href="https://www.luogu.com.cn/problem/P1042">洛谷P1042</a>)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-字符串的展开-洛谷P1098"><a href="#e-g-字符串的展开-洛谷P1098" class="headerlink" title="e.g. 字符串的展开(洛谷P1098)"></a>e.g. 字符串的展开(<a href="https://www.luogu.com.cn/problem/P1098">洛谷P1098</a>)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-国王的魔镜-洛谷P2799"><a href="#e-g-国王的魔镜-洛谷P2799" class="headerlink" title="e.g. 国王的魔镜(洛谷P2799)"></a>e.g. 国王的魔镜(<a href="https://www.luogu.com.cn/problem/P2799">洛谷P2799</a>)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-拼数-洛谷P1012"><a href="#e-g-拼数-洛谷P1012" class="headerlink" title="e.g. 拼数(洛谷P1012)"></a>e.g. 拼数(<a href="https://www.luogu.com.cn/problem/P1012">洛谷P1012</a>)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-表达式求值-洛谷P1981"><a href="#e-g-表达式求值-洛谷P1981" class="headerlink" title="e.g. 表达式求值(洛谷P1981)"></a>e.g. 表达式求值(<a href="https://www.luogu.com.cn/problem/P1981">洛谷P1981</a>)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-重复字符串-洛谷P8739"><a href="#e-g-重复字符串-洛谷P8739" class="headerlink" title="e.g. 重复字符串(洛谷P8739)"></a>e.g. 重复字符串(<a href="https://www.luogu.com.cn/problem/P8739">洛谷P8739</a>)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-编辑距离-洛谷P2758"><a href="#e-g-编辑距离-洛谷P2758" class="headerlink" title="e.g. 编辑距离(洛谷P2758)"></a>e.g. 编辑距离(<a href="https://www.luogu.com.cn/problem/P2758">洛谷P2758</a>)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-单词背诵-洛谷P1381"><a href="#e-g-单词背诵-洛谷P1381" class="headerlink" title="e.g. 单词背诵(洛谷P1381)"></a>e.g. 单词背诵(<a href="https://www.luogu.com.cn/problem/P1381">洛谷P1381</a>)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-家谱-洛谷P2814"><a href="#e-g-家谱-洛谷P2814" class="headerlink" title="e.g. 家谱(洛谷P2814)"></a>e.g. 家谱(<a href="https://www.luogu.com.cn/problem/P2814">洛谷P2814</a>)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-俄罗斯方块-洛谷P2814"><a href="#e-g-俄罗斯方块-洛谷P2814" class="headerlink" title="e.g. 俄罗斯方块(洛谷P2814)"></a>e.g. 俄罗斯方块(<a href="https://www.luogu.com.cn/problem/P2814">洛谷P2814</a>)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 学习记录 </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泉州暑假集训Day 5 &amp;&amp; 6</title>
      <link href="/2023/07undefined.html"/>
      <url>/2023/07undefined.html</url>
      
        <content type="html"><![CDATA[<p>PS: This is a note.</p><h2 id="深搜-DFS-和宽搜-BFS"><a href="#深搜-DFS-和宽搜-BFS" class="headerlink" title="深搜(DFS)和宽搜(BFS)"></a>深搜(DFS)和宽搜(BFS)</h2><span id="more"></span><h3 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h3><p><strong>搜索算法是计算机程序设计中一种最基本、最常用的算法。</strong></p><p><strong>当我们面对一个程序设计问题时，如果能找到数学方法（如递推法、构造法）或者类似贪心、动态规划求最优值的方法时，那么对于这道题而言，已经基本解决。</strong></p><p>如果没有找到行之有效的方法，搜索便成了唯一的选择。</p><p>搜索算法又被称为<strong>通用解题法</strong>，想不到正解的题目总是可以通过搜索算法来获取一部分分数(骗分)。搜索题也往往是普通选手和高手之间拉开差距的<strong>关键所在。</strong><br>所以我们常说：**<font color="red">搜索不是万能的，没有搜索是万万不能的。</font>**</p><p><strong>搜索算法是利用计算机的高性能来有目的的穷举一个问题解空间的部分或所有的可能情况，从而求出问题的解的一种方法。</strong></p><p><strong>搜索过程实际上是根据初始条件和扩展规则构造一棵解答树并寻找符合目标状态的节点的过程。</strong></p><p>由于搜索策略的不同，搜索算法可以分为两种基本情况，即: 深度优先搜索和宽度优先搜索。</p><h3 id="深搜和宽搜的区别"><a href="#深搜和宽搜的区别" class="headerlink" title="深搜和宽搜的区别"></a>深搜和宽搜的区别</h3><table><thead><tr><th align="center"></th><th align="center">深度优先搜索</th><th align="center">宽度优先搜索</th></tr></thead><tbody><tr><td align="center">数据结构</td><td align="center">栈</td><td align="center">队列</td></tr><tr><td align="center">使用场景</td><td align="center">求可行解或全部解</td><td align="center">求最优解</td></tr><tr><td align="center">时间和空间</td><td align="center">需要较少的空间,但容易超时,需要优化</td><td align="center">能最快求得解,但需要与状态数成正比的空间</td></tr></tbody></table><h3 id="深度优先搜索-Depth-first-Search"><a href="#深度优先搜索-Depth-first-Search" class="headerlink" title="深度优先搜索(Depth-first-Search)"></a><a href="https://zh.wikipedia.org/zh-hans/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">深度优先搜索(Depth-first-Search)</a></h3><p><img src="/../img/%E6%B3%89%E5%B7%9E%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD/Depth-first-search.png" alt="节点进行深度优先搜索的顺序"></p><h3 id="深搜的基本框架-回溯"><a href="#深搜的基本框架-回溯" class="headerlink" title="深搜的基本框架(回溯)"></a>深搜的基本框架(回溯)</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void dfs(int dep){    if(当前状态==目标状态)        输出解或者作计数、评价处理;    else        for(int i=1;i&lt;=状态的扩展可能数;i++){            if(第i种状态扩展可行){                保存现场(断点,维护参数表);                dfs(dep+1);                恢复现场(回溯，回到上一个断点继续执行)            }        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="深搜例题"><a href="#深搜例题" class="headerlink" title="深搜例题"></a>深搜例题</h3><h4 id="e-g-全排列问题-洛谷P1706"><a href="#e-g-全排列问题-洛谷P1706" class="headerlink" title="e.g. 全排列问题(洛谷P1706)"></a>e.g. 全排列问题(<a href="https://www.luogu.com.cn/problem/P1706">洛谷P1706</a>)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int n,a[11],p[11];void dfs(int t){if(t&gt;n){for(int i=1;i&lt;=n;i++){printf("%5d",a[i]);}printf("\n");return;}for(int i=1;i&lt;=n;i++)//每位都有n种可能{if(!p[i])//如果i没被用过{a[t]=i;//该位的数是ip[i]=1;//i被用过了dfs(t+1);//继续下一位p[i]=0;//返回到上一位时，回溯}}}int main() {cin&gt;&gt;n;dfs(1);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="e-g-数字三角形"><a href="#e-g-数字三角形" class="headerlink" title="e.g. 数字三角形"></a>e.g. 数字三角形</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="宽度优先搜索-Breadth-first-Search-又译作广度优先搜索"><a href="#宽度优先搜索-Breadth-first-Search-又译作广度优先搜索" class="headerlink" title="宽度优先搜索(Breadth-first Search,又译作广度优先搜索)"></a><a href="https://zh.wikipedia.org/zh-hans/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">宽度优先搜索(Breadth-first Search,又译作广度优先搜索)</a></h3><p><img src="/../img/%E6%B3%89%E5%B7%9E%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD/Breadth-first-search.png" alt="节点进行宽度优先搜索的顺序"></p><h3 id="宽搜例题"><a href="#宽搜例题" class="headerlink" title="宽搜例题"></a>宽搜例题</h3><h4 id="e-g-关系网络"><a href="#e-g-关系网络" class="headerlink" title="e.g. 关系网络"></a>e.g. 关系网络</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-奇怪的电梯"><a href="#e-g-奇怪的电梯" class="headerlink" title="e.g. 奇怪的电梯"></a>e.g. 奇怪的电梯</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-最大黑区域-DFS和BFS皆可解决"><a href="#e-g-最大黑区域-DFS和BFS皆可解决" class="headerlink" title="e.g. 最大黑区域(DFS和BFS皆可解决)"></a>e.g. 最大黑区域(DFS和BFS皆可解决)</h4><h5 id="程序填空版"><a href="#程序填空版" class="headerlink" title="程序填空版"></a><a href="http://www.smcoj.com/problem.php?id=1991">程序填空版</a></h5><h5 id="OJ"><a href="#OJ" class="headerlink" title="OJ"></a><a href="https://www.caoweninfo.com/problem.php?id=1904">OJ</a></h5><h5 id="DFS解法"><a href="#DFS解法" class="headerlink" title="DFS解法"></a><a href="https://blog.nowcoder.net/n/7948f5c26bc14b64b919fd27831f9332">DFS解法</a></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-位图-洛谷P2335"><a href="#e-g-位图-洛谷P2335" class="headerlink" title="e.g. 位图(洛谷P2335)"></a>e.g. 位图(<a href="https://www.luogu.com.cn/problem/P2335">洛谷P2335</a>)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 学习记录 </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泉州暑假集训Day 4</title>
      <link href="/2023/07undefined.html"/>
      <url>/2023/07undefined.html</url>
      
        <content type="html"><![CDATA[<p>PS: This is a note.</p><h2 id="杂题选讲"><a href="#杂题选讲" class="headerlink" title="杂题选讲"></a>杂题选讲</h2><span id="more"></span><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>时间复杂度</li><li>空间复杂度</li><li>有限的资源解决问题，不断优化</li></ul><h3 id="心灵鸡汤"><a href="#心灵鸡汤" class="headerlink" title="心灵鸡汤"></a>心灵鸡汤</h3><ul><li>态度决定一切</li><li>细节决定成败</li><li>心态决定人生</li></ul><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><h4 id="铺地毯-信息学奥赛一本通（C-版）在线评测系统-题号1863"><a href="#铺地毯-信息学奥赛一本通（C-版）在线评测系统-题号1863" class="headerlink" title="铺地毯(信息学奥赛一本通（C++版）在线评测系统 题号1863"></a>铺地毯(<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1863">信息学奥赛一本通（C++版）在线评测系统 题号1863</a></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="解密-Decode-信息学奥赛一本通（C-版）在线评测系统-题号2087"><a href="#解密-Decode-信息学奥赛一本通（C-版）在线评测系统-题号2087" class="headerlink" title="解密(Decode)(信息学奥赛一本通（C++版）在线评测系统 题号2087"></a>解密(Decode)(<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=2087">信息学奥赛一本通（C++版）在线评测系统 题号2087</a></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="分糖果-信息学奥赛一本通（C-版）在线评测系统-题号2074"><a href="#分糖果-信息学奥赛一本通（C-版）在线评测系统-题号2074" class="headerlink" title="分糖果(信息学奥赛一本通（C++版）在线评测系统 题号2074"></a>分糖果(<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=2074">信息学奥赛一本通（C++版）在线评测系统 题号2074</a></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="优秀的拆分"><a href="#优秀的拆分" class="headerlink" title="优秀的拆分"></a>优秀的拆分</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="报数"><a href="#报数" class="headerlink" title="报数"></a>报数</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 学习记录 </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泉州暑假集训Day 3</title>
      <link href="/2023/07undefined.html"/>
      <url>/2023/07undefined.html</url>
      
        <content type="html"><![CDATA[<p>PS: This is a note.</p><h2 id="动态规划-DP"><a href="#动态规划-DP" class="headerlink" title="动态规划(DP)"></a>动态规划(DP)</h2><span id="more"></span><h3 id="构成动态规划算法的三要素"><a href="#构成动态规划算法的三要素" class="headerlink" title="构成动态规划算法的三要素"></a>构成动态规划算法的三要素</h3><p>动态规划对<strong>状态空间</strong>的<strong>遍历</strong>构成一张<strong>有向无环图</strong>，遍历顺序就是该有向无环图的一个<strong>拓扑序</strong></p><ul><li>有向无环图中的节点对应问题中的 <strong>“状态”</strong></li><li>图中的边对应状态之间的 <strong>“转移”</strong></li><li>转移的选取就是动态规划中的 <strong>“决策”</strong></li></ul><h3 id="问题能用动态规划求解的三个基本条件"><a href="#问题能用动态规划求解的三个基本条件" class="headerlink" title="问题能用动态规划求解的三个基本条件"></a>问题能用动态规划求解的三个基本条件</h3><ul><li>子问题重叠性————有些子问题会被重复计算多次，动态规划算法对每一个子问题只计算一次，然后将其计算结果保存下来，当再次需要计算已经计算过的子问题时，直接返回之前记录的结果，从而获得较高的效率</li><li>无后效性————动态规划要求已经求解的子问题不受后续阶段的影响，即每个状态都是过去历史的一个完整总结</li><li>最优子结构性质————问题的最优解,其所包含的子问题的解也是最优的</li></ul><h3 id="DP例题"><a href="#DP例题" class="headerlink" title="DP例题"></a>DP例题</h3><h4 id="e-g-最少硬币找钱问题"><a href="#e-g-最少硬币找钱问题" class="headerlink" title="e.g. 最少硬币找钱问题"></a>e.g. 最少硬币找钱问题</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-数字金子塔-II"><a href="#e-g-数字金子塔-II" class="headerlink" title="e.g. 数字金子塔 II"></a>e.g. 数字金子塔 II</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-红牌-洛谷P1130"><a href="#e-g-红牌-洛谷P1130" class="headerlink" title="e.g. 红牌(洛谷P1130)"></a>e.g. 红牌(<a href="https://www.luogu.com.cn/problem/P1130">洛谷P1130</a>)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-传球游戏-洛谷P1057"><a href="#e-g-传球游戏-洛谷P1057" class="headerlink" title="e.g. 传球游戏(洛谷P1057)"></a>e.g. 传球游戏(<a href="https://www.luogu.com.cn/problem/P1057">洛谷P1057</a>)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-方格取数-洛谷P1004"><a href="#e-g-方格取数-洛谷P1004" class="headerlink" title="e.g. 方格取数(洛谷P1004)"></a>e.g. 方格取数(<a href="https://www.luogu.com.cn/problem/P1004">洛谷P1004</a>)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="最长上升子序列-LIS"><a href="#最长上升子序列-LIS" class="headerlink" title="最长上升子序列(LIS)"></a>最长上升子序列(LIS)</h3><h4 id="LIS例题"><a href="#LIS例题" class="headerlink" title="LIS例题"></a>LIS例题</h4><h5 id="e-g-怪盗基德的滑翔翼-信息学奥赛一本通（C-版）在线评测系统-题号1286"><a href="#e-g-怪盗基德的滑翔翼-信息学奥赛一本通（C-版）在线评测系统-题号1286" class="headerlink" title="e.g. 怪盗基德的滑翔翼(信息学奥赛一本通（C++版）在线评测系统 题号1286)"></a>e.g. 怪盗基德的滑翔翼(<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1286">信息学奥赛一本通（C++版）在线评测系统 题号1286</a>)</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="e-g-登山-信息学奥赛一本通（C-版）在线评测系统-题号1283"><a href="#e-g-登山-信息学奥赛一本通（C-版）在线评测系统-题号1283" class="headerlink" title="e.g. 登山(信息学奥赛一本通（C++版）在线评测系统 题号1283)"></a>e.g. 登山(<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1283">信息学奥赛一本通（C++版）在线评测系统 题号1283</a>)</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="e-g-友好城市-信息学奥赛一本通（C-版）在线评测系统-题号1263"><a href="#e-g-友好城市-信息学奥赛一本通（C-版）在线评测系统-题号1263" class="headerlink" title="e.g. 友好城市(信息学奥赛一本通（C++版）在线评测系统 题号1263)"></a>e.g. 友好城市(<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1263">信息学奥赛一本通（C++版）在线评测系统 题号1263</a>)</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="e-g-最长上升子序列和-信息学奥赛一本通（C-版）在线评测系统-题号1285"><a href="#e-g-最长上升子序列和-信息学奥赛一本通（C-版）在线评测系统-题号1285" class="headerlink" title="e.g. 最长上升子序列和(信息学奥赛一本通（C++版）在线评测系统 题号1285)"></a>e.g. 最长上升子序列和(<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1285">信息学奥赛一本通（C++版）在线评测系统 题号1285</a>)</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p><code>01背包公式: f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i])</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int f[2][1010],v[1010],w[1010];int n,m,p;int main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)    {        cin&gt;&gt;v[i]&gt;&gt;w[i];    }    for(int i=1;i&lt;=n;i++)    {        //动规方程                for(int j=0;j&lt;=m;j++)        {            f[1][j]=f[0][j];            if(j&gt;=v[i])            {                f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i]);            }        }        //优化(时间上无法优化，优化空间)        p^=1;        for(int j=0;j&lt;=m;j++)        {            f[p][j]=f[p^1][j];            if(j&gt;=v[i])            {                f[p][j]=max(f[0][j],f[0][j-v[i]]+w[i]);            }        }    }    cout&lt;&lt;f[1][m]&lt;&lt;endl;    cout&lt;&lt;f[p][m]&lt;&lt;endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 学习记录 </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泉州暑假集训Day 2</title>
      <link href="/2023/07undefined.html"/>
      <url>/2023/07undefined.html</url>
      
        <content type="html"><![CDATA[<p>PS: This is a note.</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><span id="more"></span><h3 id="数据结构-DS"><a href="#数据结构-DS" class="headerlink" title="数据结构(DS)"></a>数据结构(DS)</h3><p>高效的组织数据的一种方式</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>最简单的数据结构是<strong>数组(array)</strong>: <code>int n[101];</code></p><p>数组属于数据结构中的用顺序结构实现的线性表</p><p>注: 线性表是一维的，可以用顺序结构和链式结构实现</p><h3 id="栈的使用"><a href="#栈的使用" class="headerlink" title="栈的使用"></a>栈的使用</h3><p>栈是一种基本的顺序结构，属于特殊的线性表(操作受限，特性: 后进先出————只能在一端插入和删除)</p><p>我们通常把元素插入栈叫做<strong>进栈(PUSH)</strong>,删除栈内元素叫<strong>出栈(POP)</strong></p><ul><li>栈中可以插入和删除的一段叫栈顶</li><li>另一端叫做栈底</li><li>用一个指针TOP指向栈顶，若TOP=0，表示栈空，TOP=N时栈满，进栈时TOP加1，退栈时TOP减1。栈指针在运算中永远指向栈顶</li></ul><h3 id="实现栈的常用方法"><a href="#实现栈的常用方法" class="headerlink" title="实现栈的常用方法"></a>实现栈的常用方法</h3><h4 id="数组模拟栈"><a href="#数组模拟栈" class="headerlink" title="数组模拟栈"></a>数组模拟栈</h4><h4 id="STL模拟栈"><a href="#STL模拟栈" class="headerlink" title="STL模拟栈"></a>STL模拟栈</h4><h3 id="栈例题"><a href="#栈例题" class="headerlink" title="栈例题"></a>栈例题</h3><h4 id="e-g-后缀表达式求值-洛谷P1449"><a href="#e-g-后缀表达式求值-洛谷P1449" class="headerlink" title="e.g. 后缀表达式求值(洛谷P1449)"></a>e.g. 后缀表达式求值(<a href="https://www.luogu.com.cn/problem/P1449">洛谷P1449</a>)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;stack&lt;int&gt; sta;//运用STL中的栈可能超时，当遇到过大的元素时应用数组string s;int main(){int temp=0,x,y;cin&gt;&gt;s;for(int i=0; i&lt;s.size(); i++) {if(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9') {temp=temp*10+s[i]-'0';}if(s[i]=='@'){break;}else if(s[i]=='.') {sta.push(temp),temp=0;}if(s[i]=='+') {x=sta.top();sta.pop();y=sta.top();sta.pop();sta.push(y+x);}if(s[i]=='-') {x=sta.top();sta.pop();y=sta.top();sta.pop();sta.push(y-x);}if(s[i]=='*') {x=sta.top();sta.pop();y=sta.top();sta.pop();sta.push(y*x);}if(s[i]=='/') {x=sta.top();sta.pop();y=sta.top();sta.pop();sta.push(y/x);}}cout&lt;&lt;sta.top();return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="e-g-中缀表达式转后缀表达式"><a href="#e-g-中缀表达式转后缀表达式" class="headerlink" title="e.g. 中缀表达式转后缀表达式"></a>e.g. 中缀表达式转后缀表达式</h4><p>解法: <a href="https://juejin.cn/s/c%2B%2B%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B9%B6%E8%AE%A1%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC">稀土掘金</a></p><h2 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列(queue)"></a>队列(queue)</h2><p>队列是一种线性表</p><h3 id="队列例题"><a href="#队列例题" class="headerlink" title="队列例题"></a>队列例题</h3><h4 id="e-g-Blah数集-信息学奥赛一本通（C-版）在线评测系统-题号1333"><a href="#e-g-Blah数集-信息学奥赛一本通（C-版）在线评测系统-题号1333" class="headerlink" title="e.g. Blah数集(信息学奥赛一本通（C++版）在线评测系统 题号1333)"></a>e.g. Blah数集(<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1333">信息学奥赛一本通（C++版）在线评测系统 题号1333</a>)</h4><p>解法: <a href="https://blog.csdn.net/HybridCOW_HORSE/article/details/124501746">CSDN</a></p><h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义:"></a>树的定义:</h3><ul><li>树是一种<strong>非线性</strong>的数据结构</li><li>树是若干<strong>结点</strong>的集合，是由唯一的<strong>根</strong>和若干<strong>子树</strong>组成</li><li>树的定义本身就是<strong>递归</strong>的</li></ul><h3 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h3><h4 id="度"><a href="#度" class="headerlink" title="度"></a>度</h4><ol><li><strong>结点的度</strong>: 结点拥有的字数个数</li><li><strong>树的度</strong>: 一棵树中，最大的结点的度</li></ol><h4 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h4><ol><li><strong>叶结点或终端结点</strong>: 度为零的节点</li><li><strong>父亲结点或父结点</strong>: 若一个节点含有子结点，则这个结点称为其子结点的父结点</li><li><strong>孩子结点或子结点</strong>: 一个结点含有的子树的根结点</li><li><strong>兄弟结点</strong>: 具有相同父结点的节点互称为兄弟结点</li><li><strong>结点的层次</strong>: 根开始定义起，根为第1层，根的子结点为第2层，以此类推</li><li><strong>堂兄弟结点</strong>：父结点在同一层的结点互为堂兄弟</li><li><strong>结点的祖先</strong>：从根到该结点所经分支上的所有结点</li></ol><h4 id="高度或和深度"><a href="#高度或和深度" class="headerlink" title="高度或和深度"></a>高度或和深度</h4><ol><li><strong>树的高度或深度</strong>: 树中结点的最大层次称为树的深度</li><li>深度较为常用</li></ol><h4 id="有序树和无序树"><a href="#有序树和无序树" class="headerlink" title="有序树和无序树"></a>有序树和无序树</h4><ol><li><strong>有序树</strong>: 树中结点的子树从左到右是有次序的，不能交换</li><li><strong>无序树</strong>: 树中结点的子树没有顺序，可以任意交换</li></ol><p>详细可以看<a href="https://blog.csdn.net/BlackLJ/article/details/122053118?utm_source=app&amp;app_version=6.1.0">这篇博客</a></p><p>注: 结点和节点都是正确的</p><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><p>在一般的树上加上如下两个限制条件就得到了二叉树</p><ul><li>每个结点最多只有两棵子树，即二叉树中的结点的度只能为0，1，2</li><li>子树有左右之分，不能颠倒</li><li>根据二叉树的定义共有5种基本形态:”空二叉树”、”只有根节点”、”只有左子树，右子树为空”、”只有右子树,左子树为空”、”既有左子树，又有右子树”</li></ul><h4 id="满二叉树-所有分支结点都有子结点-的定义"><a href="#满二叉树-所有分支结点都有子结点-的定义" class="headerlink" title="满二叉树(所有分支结点都有子结点)的定义"></a>满二叉树(所有分支结点都有子结点)的定义</h4><ul><li>在一棵二叉树中，如果所有的分支结点都有左孩子和右孩子结点，并且叶子结点都集中在二叉树的最下一层，则这样的二叉树称为满二叉树</li></ul><h4 id="完全二叉树的定义"><a href="#完全二叉树的定义" class="headerlink" title="完全二叉树的定义"></a>完全二叉树的定义</h4><ul><li>如果对一棵深度为k、有n个结点的二叉树进行编号后，各结点的编号与深度为k的满二叉树中相同位置上的结点的编号均相同，那么这棵二叉树就是一棵完全二叉树</li></ul><h3 id="⭐二叉树的主要性质"><a href="#⭐二叉树的主要性质" class="headerlink" title="⭐二叉树的主要性质"></a>⭐二叉树的主要性质</h3>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 学习记录 </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泉州暑假集训Day 1</title>
      <link href="/2023/07d8c1ce2.html"/>
      <url>/2023/07d8c1ce2.html</url>
      
        <content type="html"><![CDATA[<p>PS: This is a note.</p><h2 id="数据排序"><a href="#数据排序" class="headerlink" title="数据排序"></a>数据排序</h2><span id="more"></span><h3 id="①选择排序-不稳定的排序"><a href="#①选择排序-不稳定的排序" class="headerlink" title="①选择排序: 不稳定的排序"></a>①选择排序: 不稳定的排序</h3><h3 id="e-g-输入n个数-将n个数从小到大排序"><a href="#e-g-输入n个数-将n个数从小到大排序" class="headerlink" title="e.g. 输入n个数,将n个数从小到大排序"></a>e.g. 输入n个数,将n个数从小到大排序</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">sort(a,a+n);for(int i=0;i&lt;n;i++){    cout&lt;&lt;a[i]&lt;&lt;" ";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②冒泡排序-从后往前排列元素"><a href="#②冒泡排序-从后往前排列元素" class="headerlink" title="②冒泡排序: 从后往前排列元素"></a>②冒泡排序: 从后往前排列元素</h3><h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i=1;i&lt;=n;i++){    for(int j;j&lt;=n-i;j++)    {        if(a[j]&gt;a[j+1])        {            int t=a[j];            a[j]=a[j+1];            a[j+1]=t;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="e-g-将6-3-1-2-5-4从小到大排序"><a href="#e-g-将6-3-1-2-5-4从小到大排序" class="headerlink" title="e.g. 将6,3,1,2,5,4从小到大排序"></a>e.g. 将6,3,1,2,5,4从小到大排序</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i=1;i=n;i++){    for(int j=1;j&lt;=n;j++)    {        swap(a[i],a[j+1]);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注: swap是交换函数</p><h3 id="③插入排序-将元素插入一个有序表中"><a href="#③插入排序-将元素插入一个有序表中" class="headerlink" title="③插入排序: 将元素插入一个有序表中"></a>③插入排序: 将元素插入一个有序表中</h3><h4 id="e-g-d"><a href="#e-g-d" class="headerlink" title="e.g. d"></a>e.g. d</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="④桶排序-若待排序值在一个有限范围内时，可设置有限桶，最后输出各个桶的值，得出有序表的值"><a href="#④桶排序-若待排序值在一个有限范围内时，可设置有限桶，最后输出各个桶的值，得出有序表的值" class="headerlink" title="④桶排序: 若待排序值在一个有限范围内时，可设置有限桶，最后输出各个桶的值，得出有序表的值"></a>④桶排序: 若待排序值在一个有限范围内时，可设置有限桶，最后输出各个桶的值，得出有序表的值</h3><h4 id="e-g-明明的随机数"><a href="#e-g-明明的随机数" class="headerlink" title="e.g. 明明的随机数"></a>e.g. 明明的随机数</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="⑤快速排序-最好的内部排序方法"><a href="#⑤快速排序-最好的内部排序方法" class="headerlink" title="⑤快速排序: 最好的内部排序方法"></a>⑤快速排序: 最好的内部排序方法</h3><h4 id="e-g-de"><a href="#e-g-de" class="headerlink" title="e.g. de"></a>e.g. de</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注: sort是快排函数,详细可从<a href="http://c.biancheng.net/stl/algorithms/">C语言中文网</a>查看</p><h3 id="⑥归并排序-两个组的比较"><a href="#⑥归并排序-两个组的比较" class="headerlink" title="⑥归并排序: 两个组的比较"></a>⑥归并排序: 两个组的比较</h3><h4 id="e-g-ddasd"><a href="#e-g-ddasd" class="headerlink" title="e.g. ddasd"></a>e.g. ddasd</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="⑦希尔排序-直接插入排序算法的一种更高效的优化算法，非稳定排序算法，类似于宏观调控"><a href="#⑦希尔排序-直接插入排序算法的一种更高效的优化算法，非稳定排序算法，类似于宏观调控" class="headerlink" title="⑦希尔排序: 直接插入排序算法的一种更高效的优化算法，非稳定排序算法，类似于宏观调控"></a>⑦希尔排序: 直接插入排序算法的一种更高效的优化算法，非稳定排序算法，类似于宏观调控</h3><h4 id="e-g-dh"><a href="#e-g-dh" class="headerlink" title="e.g. dh"></a>e.g. dh</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="⑧基数排序-属于分配式排序"><a href="#⑧基数排序-属于分配式排序" class="headerlink" title="⑧基数排序: 属于分配式排序"></a>⑧基数排序: 属于分配式排序</h3><h4 id="e-g-dl"><a href="#e-g-dl" class="headerlink" title="e.g. dl"></a>e.g. dl</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="⑨堆排序-一种近似完全二叉树的结构"><a href="#⑨堆排序-一种近似完全二叉树的结构" class="headerlink" title="⑨堆排序: 一种近似完全二叉树的结构"></a>⑨堆排序: 一种近似完全二叉树的结构</h3><h4 id="e-g-dm"><a href="#e-g-dm" class="headerlink" title="e.g. dm"></a>e.g. dm</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="递推算法"><a href="#递推算法" class="headerlink" title="递推算法"></a>递推算法</h2><h3 id="递推算法例题"><a href="#递推算法例题" class="headerlink" title="递推算法例题"></a>递推算法例题</h3><h4 id="e-g-数字三角形"><a href="#e-g-数字三角形" class="headerlink" title="e.g. 数字三角形"></a>e.g. 数字三角形</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-斐波那契数列-1-1-2-3-5-8……"><a href="#e-g-斐波那契数列-1-1-2-3-5-8……" class="headerlink" title="e.g. 斐波那契数列(1,1,2,3,5,8……)"></a>e.g. 斐波那契数列(1,1,2,3,5,8……)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main() { int n,fn,fn_1=1,fn_2=1,f[101]={0,1,1,2}; cin&gt;&gt;n; for(int i=3;i&lt;=n;i++) {  //原代码     f[i]=f[i-1]+f[i-2];     //优化后  fn=fn_1+fn_2;     fn_2=fn_1;     fn_1=fn; } cout&lt;&lt;f[n]&lt;&lt;endl&lt;&lt;fn; return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="e-g-昆虫繁殖"><a href="#e-g-昆虫繁殖" class="headerlink" title="e.g. 昆虫繁殖"></a>e.g. 昆虫繁殖</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-位数问题"><a href="#e-g-位数问题" class="headerlink" title="e.g. 位数问题"></a>e.g. 位数问题</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-过河卒"><a href="#e-g-过河卒" class="headerlink" title="e.g. 过河卒"></a>e.g. 过河卒</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-卡特兰数"><a href="#e-g-卡特兰数" class="headerlink" title="e.g. 卡特兰数"></a>e.g. 卡特兰数</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><h3 id="递归算法例题"><a href="#递归算法例题" class="headerlink" title="递归算法例题"></a>递归算法例题</h3><h4 id="e-g-给定n-n-gt-x3D-1-算1到n的累加和"><a href="#e-g-给定n-n-gt-x3D-1-算1到n的累加和" class="headerlink" title="e.g. 给定n(n>=1),算1到n的累加和"></a>e.g. 给定n(n&gt;=1),算1到n的累加和</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="e-g-汉诺塔"><a href="#e-g-汉诺塔" class="headerlink" title="e.g. 汉诺塔"></a>e.g. 汉诺塔</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注: 永远没有最优的算法</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 学习记录 </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js安装详解</title>
      <link href="/2023/06undefined.html"/>
      <url>/2023/06undefined.html</url>
      
        <content type="html"><![CDATA[<h4 id="Step1：下载安装包"><a href="#Step1：下载安装包" class="headerlink" title="Step1：下载安装包"></a>Step1：下载安装包</h4><p><a href="https://nodejs.org/zh-cn/download/">先进官网下个安装包</a></p><span id="more"></span><p><img src="/../img/nodejs%E5%AE%89%E8%A3%85/nodejs%E5%AE%89%E8%A3%851.PNG" alt="官网"></p><p><a href="https://registry.npmmirror.com/binary.html?path=node/latest-v20.x/">或者从镜像站下（我也不知道为什么镜像站的版本竟然比官网的高，How amazing!）</a></p><p><img src="/../img/nodejs%E5%AE%89%E8%A3%85/nodejs%E5%AE%89%E8%A3%852.PNG" alt="Windows版"></p><p><img src="/../img/nodejs%E5%AE%89%E8%A3%85/nodejs%E5%AE%89%E8%A3%853.PNG" alt="Linux版"></p><h4 id="Step2：安装程序"><a href="#Step2：安装程序" class="headerlink" title="Step2：安装程序"></a>Step2：安装程序</h4><h5 id="1-下载完成后，双击安装包，开始安装Node-js"><a href="#1-下载完成后，双击安装包，开始安装Node-js" class="headerlink" title="1.下载完成后，双击安装包，开始安装Node.js"></a>1.下载完成后，双击安装包，开始安装Node.js</h5><p><img src="/../img/nodejs%E5%AE%89%E8%A3%85/nodejs%E5%AE%89%E8%A3%854.PNG" alt=" "></p><p>注：这中间应该还有一个设置安装路径的界面，但我已经安装过了，所以没有，可按照个人需求修改</p><p><img src="/../img/nodejs%E5%AE%89%E8%A3%85/nodejs%E5%AE%89%E8%A3%855.PNG" alt="一路回车(&quot;next&quot;)"></p><h5 id="2-按照个人需求决定是否选中，一般不需要，决定后点击【Next】按钮"><a href="#2-按照个人需求决定是否选中，一般不需要，决定后点击【Next】按钮" class="headerlink" title="2.按照个人需求决定是否选中，一般不需要，决定后点击【Next】按钮"></a>2.按照个人需求决定是否选中，一般不需要，决定后点击【Next】按钮</h5><p><img src="/../img/nodejs%E5%AE%89%E8%A3%85/nodejs%E5%AE%89%E8%A3%856.png" alt=" "></p><h5 id="3-点击Install安装，完成后点击Finish"><a href="#3-点击Install安装，完成后点击Finish" class="headerlink" title="3.点击Install安装，完成后点击Finish"></a>3.点击Install安装，完成后点击Finish</h5><h5 id="4-测试是否安装"><a href="#4-测试是否安装" class="headerlink" title="4.测试是否安装"></a>4.测试是否安装</h5><p>按下【win+R】键，输入cmd，打开cmd窗口</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">node</span> <span class="token parameter variable">-v</span>     // 显示node.js版本<span class="token function">npm</span> <span class="token parameter variable">-v</span>      // 显示npm版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Step3：测试和配置"><a href="#Step3：测试和配置" class="headerlink" title="Step3：测试和配置"></a>Step3：测试和配置</h4><h5 id="1-npm安装测试"><a href="#1-npm安装测试" class="headerlink" title="1.npm安装测试"></a>1.npm安装测试</h5><p>试试安装常用的express模块</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// -g代表全局安装<span class="token function">npm</span> <span class="token function">install</span> express <span class="token parameter variable">-g</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../img/nodejs%E5%AE%89%E8%A3%85/nodejs%E5%AE%89%E8%A3%857.png" alt="一般没出现ERR或者卡住的现象都是成功的（图为失败的界面）"></p><p>成功的界面最新版只会显示“added n packages in n s.”（n为变量）</p><h5 id="2-npm换源"><a href="#2-npm换源" class="headerlink" title="2.npm换源"></a>2.npm换源</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 安装镜像    <span class="token function">npm</span> config <span class="token builtin class-name">set</span> registry https://registry.npm.taobao.org// 查看是否成功    <span class="token function">npm</span> config get registry<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>OK，本篇博客到此结束，下次我要阐述的便是“使用博客框架Hexo+Github搭建独属于自己的静态博客”了，Bye-bye~~ .</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 安装 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
